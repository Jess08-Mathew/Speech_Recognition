# -*- coding: utf-8 -*-
"""SPR-LAB-9.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Tw76xfkC6MAVzYP-w4XVQP14MLKwrkXD
"""

import numpy as np

# States (phonemes)
states = ['S1', 'S2', 'S3', 'S4']   # /h/ /e/ /l/ /o/
state_map = {
    'S1': '/h/',
    'S2': '/e/',
    'S3': '/l/',
    'S4': '/o/'
}

# Observations
observations = ['O1', 'O2', 'O3', 'O4']
obs_seq = ['O1', 'O2', 'O3', 'O4']

# Emission Probabilities (B)
B = {
    'S1': {'O1': 0.6, 'O2': 0.2, 'O3': 0.1, 'O4': 0.1},
    'S2': {'O1': 0.1, 'O2': 0.7, 'O3': 0.1, 'O4': 0.1},
    'S3': {'O1': 0.1, 'O2': 0.1, 'O3': 0.6, 'O4': 0.2},
    'S4': {'O1': 0.2, 'O2': 0.1, 'O3': 0.2, 'O4': 0.5}
}

# Transition Probabilities (A)
A = {
    'S1': {'S1': 0.0, 'S2': 0.7, 'S3': 0.3, 'S4': 0.0},
    'S2': {'S1': 0.0, 'S2': 0.2, 'S3': 0.6, 'S4': 0.2},
    'S3': {'S1': 0.0, 'S2': 0.0, 'S3': 0.3, 'S4': 0.7},
    'S4': {'S1': 0.0, 'S2': 0.0, 'S3': 0.1, 'S4': 0.9},
}

# Initial probabilities π
pi = {'S1': 1.0, 'S2': 0.0, 'S3': 0.0, 'S4': 0.0}

# --- VITERBI ALGORITHM ---

def viterbi(obs_seq, states, pi, A, B):
    T = len(obs_seq)
    delta = np.zeros((len(states), T))
    psi = np.zeros((len(states), T), dtype=int)

    # Initialization
    for i, s in enumerate(states):
        delta[i, 0] = pi[s] * B[s][obs_seq[0]]
        psi[i, 0] = 0

    # Recursion
    for t in range(1, T):
        for j, sj in enumerate(states):
            max_prob, max_state = max(
                (delta[i, t-1] * A[si][sj], i)
                for i, si in enumerate(states)
            )
            delta[j, t] = max_prob * B[sj][obs_seq[t]]
            psi[j, t] = max_state

    # Termination
    best_last_state = np.argmax(delta[:, T-1])
    best_prob = delta[best_last_state, T-1]

    # Backtracking
    best_path = [best_last_state]
    for t in range(T-1, 0, -1):
        best_path.insert(0, psi[best_path[0], t])

    best_state_sequence = [state_map[states[i]] for i in best_path]
    return best_state_sequence, best_prob


# Run Viterbi
best_sequence, best_probability = viterbi(obs_seq, states, pi, A, B)

print("Most likely phoneme sequence:", best_sequence)
print("Probability of sequence:", best_probability)

"""The Viterbi algorithm correctly identifies the most probable phoneme sequence for the word “hello” as /h/ → /e/ → /l/ → /o/, with a probability of 0.03704. This shows that the model successfully combines transition and emission probabilities to decode the hidden states from the observed acoustic features. The probability value reflects how likely this exact sequence is under the HMM, considering both state transitions and emissions. The result confirms that the HMM structure properly represents the phoneme flow of the word. Overall, the experiment demonstrates the effectiveness of Viterbi decoding in speech recognition tasks."""