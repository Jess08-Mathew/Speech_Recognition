# -*- coding: utf-8 -*-
"""SPR-LAB-7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13IylRABOSEWwqxuEkaURWCfU1QY5xHPV

Convert both audio files into numerical time series by extracting their waveform data.
"""

import librosa
import numpy as np

# Replace with your filenames after uploading
file1 = "audio-1.wav"
file2 = "audio-2.wav"

# Load audio files
y1, sr1 = librosa.load(file1, sr=None)   # y1 = waveform, sr1 = sampling rate
y2, sr2 = librosa.load(file2, sr=None)

print("File 1 - waveform shape:", y1.shape, "sampling rate:", sr1)
print("File 2 - waveform shape:", y2.shape, "sampling rate:", sr2)

# y1 and y2 are now numerical time series

"""Normalize both signals so they have comparable amplitude ranges."""

import numpy as np

def normalize_signal(y):
    peak = np.max(np.abs(y))
    if peak == 0:
        return y
    return y / peak

y1_norm = normalize_signal(y1)
y2_norm = normalize_signal(y2)

print("y1 normalized peak:", np.max(np.abs(y1_norm)))
print("y2 normalized peak:", np.max(np.abs(y2_norm)))

"""Apply Dynamic Time Warping on the two signals.



"""

import librosa
import numpy as np

# Extract MFCCs
mfcc1 = librosa.feature.mfcc(y=y1_norm, sr=sr1, n_mfcc=20)
mfcc2 = librosa.feature.mfcc(y=y2_norm, sr=sr2, n_mfcc=20)

print("MFCC1 shape:", mfcc1.shape)
print("MFCC2 shape:", mfcc2.shape)

!pip install fastdtw

from fastdtw import fastdtw
from scipy.spatial.distance import euclidean
import numpy as np

# Collapse MFCCs over frequency to create 1 vector per frame
mfcc1_vec = mfcc1.T   # shape: (frames, 20)
mfcc2_vec = mfcc2.T   # shape: (frames, 20)

# Run fastDTW
distance, path = fastdtw(mfcc1_vec, mfcc2_vec, dist=euclidean)

print("fastDTW distance:", distance)
print("Path length:", len(path))

import matplotlib.pyplot as plt
import numpy as np

# Convert path into two aligned index lists
path_x = [p[0] for p in path]  # indices from signal 1
path_y = [p[1] for p in path]  # indices from signal 2

plt.figure(figsize=(6,6))
plt.plot(path_x, path_y)
plt.title("fastDTW Warping Path")
plt.xlabel("Signal 1 frames")
plt.ylabel("Signal 2 frames")
plt.grid(True)
plt.show()

plt.figure(figsize=(12,4))
plt.plot(np.mean(mfcc1_vec, axis=1), label="Signal 1 (MFCC mean)")
plt.plot(np.mean(mfcc2_vec, axis=1), label="Signal 2 (MFCC mean)")
plt.title("MFCC Mean Features Over Time")
plt.legend()
plt.grid(True)
plt.show()

"""Produce the alignment path and compute the total DTW distance.

"""

!pip install fastdtw
from fastdtw import fastdtw
from scipy.spatial.distance import euclidean
import numpy as np

# Convert MFCC feature matrices into time-series of vectors
mfcc1_vec = mfcc1.T   # shape: (frames, 20)
mfcc2_vec = mfcc2.T   # shape: (frames, 20)

# Run fastDTW
dtw_distance, alignment_path = fastdtw(mfcc1_vec, mfcc2_vec, dist=euclidean)

print("DTW Distance:", dtw_distance)
print("Number of steps in alignment path:", len(alignment_path))

# Show first 10 steps of alignment path
print("Alignment path sample:", alignment_path[:10])

import matplotlib.pyplot as plt

path_x = [p[0] for p in alignment_path]
path_y = [p[1] for p in alignment_path]

plt.figure(figsize=(6,6))
plt.plot(path_x, path_y)
plt.title("fastDTW Alignment Path")
plt.xlabel("Frames of Signal 1")
plt.ylabel("Frames of Signal 2")
plt.grid(True)
plt.show()

"""**Interpret the results. Explain whether the signals are similar, and describe how DTW helps match two audio patterns that do not align perfectly in time.**

The DTW results show that the two audio signals are not very similar, as indicated by the relatively high DTW distance of about 4073. While the beginning of the signals aligns closely, the alignment path quickly shows stretches where one signal has to be matched to multiple frames of the other, meaning their timing differs significantly. DTW helps compare such signals by allowing flexible alignmentâ€”stretching or compressing sections so patterns can still be matched even if spoken at different speeds. Overall, the signals share some initial structure but diverge enough that DTW must perform substantial warping to align them.
"""