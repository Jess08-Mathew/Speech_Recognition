# -*- coding: utf-8 -*-
"""SPR-LAB-8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/104PB1jBPZoi9m2YdanRGqZUCmgHWg-1q

Represent the HMM parameters (initial probabilities, transition probabi ities, and emission probabilities) using suitable data structures in Python.
"""

import numpy as np
import random

# Hidden states (phonemes)
states = ['/s/', '/p/', '/ie:/', '/tS/']

# Observations
observations = ['Energy', 'Pitch', 'Duration']

# Initial probability
initial_prob = {'/s/': 1.0, '/p/': 0.0, '/ie:/': 0.0, '/tS/': 0.0}

# Transition probabilities
transition_prob = {
    '/s/':  {'/s/': 0.0, '/p/': 1.0, '/ie:/': 0.0, '/tS/': 0.0},
    '/p/':  {'/s/': 0.0, '/p/': 0.0, '/ie:/': 1.0, '/tS/': 0.0},
    '/ie:/':{'/s/': 0.0, '/p/': 0.0, '/ie:/': 0.0, '/tS/': 1.0},
    '/tS/': {'/s/': 0.0, '/p/': 0.0, '/ie:/': 0.0, '/tS/': 0.0}  # end state
}

# Emission probabilities
emission_prob = {
    '/s/':  {'Energy': 0.7, 'Pitch': 0.2, 'Duration': 0.1},
    '/p/':  {'Energy': 0.5, 'Pitch': 0.3, 'Duration': 0.2},
    '/ie:/':{'Energy': 0.3, 'Pitch': 0.5, 'Duration': 0.2},
    '/tS/': {'Energy': 0.4, 'Pitch': 0.4, 'Duration': 0.2}
}

""" Write a function to neatly display the transition and emission matrices along with the initial probabilities.

"""

def display_hmm():
    print("Initial Probabilities:")
    for s, p in initial_prob.items():
        print(f"  {s}: {p}")
    print("\nTransition Probabilities:")
    for s, row in transition_prob.items():
        print(f"  From {s}: {row}")
    print("\nEmission Probabilities:")
    for s, row in emission_prob.items():
        print(f"  {s}: {row}")

display_hmm()

"""Write a program to generate a single sequence of phonemes and corresponding acoustic observations for the word speech based on the defined probabilities.

"""

def sample_from_distribution(dist):
    items = list(dist.keys())
    probs = list(dist.values())
    return random.choices(items, probs)[0]

def generate_sequence():
    phoneme_sequence = []
    observation_sequence = []

    # Start at /s/
    current_state = '/s/'
    phoneme_sequence.append(current_state)

    # Emit observation for first state
    observation_sequence.append(sample_from_distribution(emission_prob[current_state]))

    # Continue until /tS/ is reached
    while current_state != '/tS/':
        next_state = sample_from_distribution(transition_prob[current_state])
        phoneme_sequence.append(next_state)

        obs = sample_from_distribution(emission_prob[next_state])
        observation_sequence.append(obs)

        current_state = next_state

    return phoneme_sequence, observation_sequence

phonemes, observations_generated = generate_sequence()
print("Generated phoneme sequence:", phonemes)
print("Generated observation sequence:", observations_generated)

"""**Write an inference for the above HMM implementation**

The implemented HMM successfully models the phoneme progression of the word “speech” using the defined transition and emission probabilities. Since the initial probability forces the model to start at /s/ and transitions are deterministic, the generated phoneme sequence always follows the expected path: /s/ → /p/ → /ie:/ → /tS/. The emitted observations vary because they are sampled probabilistically based on each phoneme’s acoustic characteristics. This demonstrates how HMMs capture both hidden linguistic structure (phonemes) and observable acoustic features. Overall, the experiment shows that HMMs are effective for simulating and understanding speech generation and phoneme-to-acoustic relationships.
"""