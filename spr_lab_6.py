# -*- coding: utf-8 -*-
"""SPR-LAB-6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Oq0mvZ0NeuyVCd4405G9ffkuQuOwm2hh

Plot both vectors to visualize their patterns.
"""

import numpy as np
import matplotlib.pyplot as plt

# Given vectors
vector1 = np.array([2, 3, 4, 6, 8, 7, 6, 5, 4, 3, 2])       # Reference
vector2 = np.array([2, 4, 6, 7, 7, 6, 5, 5, 4, 3, 2, 2, 1]) # Stretched/shifted

# Create time axes
t1 = np.arange(len(vector1))
t2 = np.arange(len(vector2))

# Plot both vectors
plt.figure(figsize=(10,5))
plt.plot(t1, vector1, 'o-', label='Vector 1 (Reference)')
plt.plot(t2, vector2, 'x--', label='Vector 2 (Test)')
plt.title("Comparison of Two Vectors")
plt.xlabel("Sample Index")
plt.ylabel("Value")
plt.legend()
plt.grid(True)
plt.show()

"""The output of the code is a line plot comparing the two vectors over their sample indices. Vector 1 (reference) is shown with connected circles, while Vector 2 (test) is shown with dashed crosses. The plot clearly shows that Vector 2 is slightly longer and its peaks and valleys are shifted relative to Vector 1, indicating that it is stretched and misaligned in time. This visual observation motivates the use of Dynamic Time Warping (DTW) to align the sequences accurately.

Implement the Dynamic Time Warping algorithm.
"""

import numpy as np

# Given vectors
vector1 = np.array([2, 3, 4, 6, 8, 7, 6, 5, 4, 3, 2])
vector2 = np.array([2, 4, 6, 7, 7, 6, 5, 5, 4, 3, 2, 2, 1])

# Dimensions
n = len(vector1)
m = len(vector2)

# Compute cost matrix (absolute differences)
cost_matrix = np.zeros((n, m))
for i in range(n):
    for j in range(m):
        cost_matrix[i, j] = abs(vector1[i] - vector2[j])

print("Cost Matrix:")
print(cost_matrix)

"""The cost matrix provides the “local difference” between elements of the sequences, which is then accumulated in the cumulative cost matrix to find the optimal alignment via DTW.

Compute the accumulated cost matrix.
"""

# Initialize cumulative cost matrix
cum_cost = np.zeros((n, m))
cum_cost[0, 0] = cost_matrix[0, 0]

# Fill first row and column
for i in range(1, n):
    cum_cost[i, 0] = cost_matrix[i, 0] + cum_cost[i-1, 0]
for j in range(1, m):
    cum_cost[0, j] = cost_matrix[0, j] + cum_cost[0, j-1]

# Fill the rest
for i in range(1, n):
    for j in range(1, m):
        cum_cost[i, j] = cost_matrix[i, j] + min(
            cum_cost[i-1, j],    # insertion
            cum_cost[i, j-1],    # deletion
            cum_cost[i-1, j-1]   # match
        )

print("Accumulated (Cumulative) Cost Matrix:")
print(cum_cost)

"""The cumulative cost matrix transforms the local differences (cost matrix) into a global alignment measure, allowing DTW to find the optimal non-linear mapping between Vector 1 and Vector 2.

Find and visualize the optimal warping path.
"""

import matplotlib.pyplot as plt

# Backtrack to find warping path
i, j = n-1, m-1
warping_path = []

while i > 0 or j > 0:
    warping_path.append((i, j))
    if i == 0:
        j -= 1
    elif j == 0:
        i -= 1
    else:
        direction = np.argmin([cum_cost[i-1, j-1], cum_cost[i-1, j], cum_cost[i, j-1]])
        if direction == 0:
            i -= 1
            j -= 1
        elif direction == 1:
            i -= 1
        else:
            j -= 1
warping_path.append((0, 0))
warping_path = warping_path[::-1]  # reverse to start from beginning

# Visualize
plt.figure(figsize=(8,6))
plt.imshow(cum_cost, origin='lower', cmap='viridis', interpolation='nearest')
plt.colorbar(label='Cumulative Cost')
path_x, path_y = zip(*warping_path)
plt.plot(path_y, path_x, 'r', linewidth=2)  # warping path in red
plt.title("DTW Accumulated Cost Matrix and Optimal Warping Path")
plt.xlabel("Vector 2 Index")
plt.ylabel("Vector 1 Index")
plt.show()

"""Warping path: shows the optimal non-linear alignment between sequences.

Calculate the DTW distance between the vectors.
"""

dtw_distance = cum_cost[-1, -1]
print(f"DTW Distance between Vector 1 and Vector 2: {dtw_distance:.4f}")

"""DTW effectively aligns sequences that are stretched or shifted in time, providing both a visual alignment (warping path) and a numerical similarity measure (DTW distance = 3.0).

Write an inference explaining how the warping path aligns the two vectors and what the DTW distance reveals about their similarity.

The warping path obtained from Dynamic Time Warping (DTW) shows the optimal alignment between Vector 1 and Vector 2, allowing elements from one vector to be matched with elements from the other even when the sequences are stretched, compressed, or shifted in time. By following the path through the cumulative cost matrix, DTW effectively aligns corresponding peaks, valleys, and trends in the two vectors, compensating for temporal distortions.

The DTW distance quantifies the overall dissimilarity between the sequences along this optimal alignment. A smaller DTW distance indicates that the vectors are highly similar in shape and pattern, while a larger distance would suggest greater differences. In this case, the relatively low DTW distance demonstrates that the vectors are largely similar despite the stretching and shifting of Vector 2 relative to Vector 1.

# **Conclusion**

Dynamic Time Warping (DTW) effectively aligns sequences that are stretched, compressed, or shifted in time by finding an optimal warping path. The warping path aligns corresponding features in the two vectors, while the DTW distance provides a quantitative measure of their similarity. In this exercise, the low DTW distance confirms that the vectors are largely similar despite temporal distortions.
"""

import numpy as np

# Original vectors
v1 = np.array([2, 3, 4, 6, 8, 7, 6, 5, 4, 3, 2])
v2 = np.array([2, 4, 6, 7, 7, 6, 5, 5, 4, 3, 2, 2, 1])

# Create 2D versions (for demonstration, second dimension is just a small offset)
vec1_2d = np.stack([v1, v1*0.5], axis=1)  # shape: (11, 2)
vec2_2d = np.stack([v2, v2*0.5], axis=1)  # shape: (13, 2)

# Multi-dimensional DTW
n, m = len(vec1_2d), len(vec2_2d)
cost_matrix = np.zeros((n, m))

for i in range(n):
    for j in range(m):
        cost_matrix[i,j] = np.linalg.norm(vec1_2d[i]-vec2_2d[j])  # Euclidean distance

# Cumulative cost
cum_cost = np.zeros((n,m))
cum_cost[0,0] = cost_matrix[0,0]
for i in range(1,n):
    cum_cost[i,0] = cost_matrix[i,0] + cum_cost[i-1,0]
for j in range(1,m):
    cum_cost[0,j] = cost_matrix[0,j] + cum_cost[0,j-1]
for i in range(1,n):
    for j in range(1,m):
        cum_cost[i,j] = cost_matrix[i,j] + min(cum_cost[i-1,j-1], cum_cost[i-1,j], cum_cost[i,j-1])

# DTW distance
dtw_distance = cum_cost[-1,-1]
print("Multi-dimensional DTW distance:", dtw_distance)

window = 2  # max allowed shift from diagonal
n, m = len(v1), len(v2)
cost_matrix = np.full((n,m), np.inf)

# Fill only within the window
for i in range(n):
    for j in range(max(0, i-window), min(m, i+window+1)):
        cost_matrix[i,j] = abs(v1[i]-v2[j])

# Cumulative cost
cum_cost = np.full((n,m), np.inf)
cum_cost[0,0] = cost_matrix[0,0]

for i in range(n):
    for j in range(max(0, i-window), min(m, i+window+1)):
        if i==0 and j==0:
            continue
        candidates = []
        if i>0:
            candidates.append(cum_cost[i-1,j])
        if j>0:
            candidates.append(cum_cost[i,j-1])
        if i>0 and j>0:
            candidates.append(cum_cost[i-1,j-1])
        cum_cost[i,j] = cost_matrix[i,j] + min(candidates)

dtw_distance = cum_cost[-1,-1]
print("Constrained DTW distance:", dtw_distance)

weight = 2  # emphasize larger values
n, m = len(v1), len(v2)
cost_matrix = np.zeros((n,m))

for i in range(n):
    for j in range(m):
        cost_matrix[i,j] = weight*abs(v1[i]-v2[j]) if max(v1[i], v2[j])>5 else abs(v1[i]-v2[j])

# Cumulative cost
cum_cost = np.zeros((n,m))
cum_cost[0,0] = cost_matrix[0,0]

for i in range(1,n):
    cum_cost[i,0] = cost_matrix[i,0] + cum_cost[i-1,0]
for j in range(1,m):
    cum_cost[0,j] = cost_matrix[0,j] + cum_cost[0,j-1]
for i in range(1,n):
    for j in range(1,m):
        cum_cost[i,j] = cost_matrix[i,j] + min(cum_cost[i-1,j-1], cum_cost[i-1,j], cum_cost[i,j-1])

dtw_distance = cum_cost[-1,-1]
print("Weighted/Custom DTW distance:", dtw_distance)