# -*- coding: utf-8 -*-
"""SpeechRecognition-2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1S69jO44bRQZfYZPJY5fPXO5z4kFKrb7y

(a) Generate a basic sinusoidal signal in the time domain. (For example, generate a sine wave with a frequency of 5 Hz, sampled at 1000 Hz.)
"""

import numpy as np
import matplotlib.pyplot as plt

# Step 1: Generate Signal
fs = 1000          # Sampling frequency (Hz)
f = 5              # Signal frequency (Hz)
T = 1              # Duration (s)
t = np.arange(0, T, 1/fs)  # Time vector
x = np.sin(2*np.pi*f*t)    # Sinusoidal signal

"""(b) Plot the time-domain waveform of the signal."""

# Step 2: Time-Domain Plot

plt.figure(figsize=(10, 4))
plt.plot(t, x)
plt.title("Time-Domain Signal (5 Hz Sine Wave)")
plt.xlabel("Time [s]")
plt.ylabel("Amplitude")
plt.xlim(0, 0.5)
plt.grid()
plt.show()

"""(c) Compute the Discrete-Time Fourier Transform (DTFT) and plot the continuous frequency spectrum."""

# Step 3: DTFT

Nfft = 8192
X_dtft = np.fft.fft(x, Nfft)
freq_dtft = np.fft.fftfreq(Nfft, d=1/fs)

# Only take positive frequencies
pos_mask = freq_dtft >= 0
plt.figure(figsize=(10, 4))
plt.plot(freq_dtft[pos_mask], np.abs(X_dtft[pos_mask]))
plt.title("DTFT (Approximation) - Magnitude Spectrum")
plt.xlabel("Frequency [Hz]")
plt.ylabel("Magnitude")
plt.grid()
plt.show()

"""(d) Compute the Discrete Fourier Transform (DFT) and plot the discrete frequency spectrum."""

# Step 4: DFT

N = len(x)
X_dft = np.fft.fft(x)
freq_dft = np.fft.fftfreq(N, d=1/fs)

plt.figure(figsize=(10, 4))
plt.stem(freq_dft[freq_dft >= 0], np.abs(X_dft[freq_dft >= 0]), basefmt=" ")
plt.title("DFT - Discrete Frequency Spectrum")
plt.xlabel("Frequency [Hz]")
plt.ylabel("Magnitude")
plt.grid()
plt.show()

"""(a) Generate a composite signal by adding two or more sinusoidal signals of different frequencies and amplitudes."""

import numpy as np
import matplotlib.pyplot as plt


# Step 1: Generate Composite Signal

fs = 1000   # Sampling frequency
T = 1       # Duration in seconds
t = np.arange(0, T, 1/fs)

# Frequencies and amplitudes
f1, A1 = 5, 1.0
f2, A2 = 20, 0.5

# Composite signal
x = A1*np.sin(2*np.pi*f1*t) + A2*np.sin(2*np.pi*f2*t)

"""(b) Plot the time-domain waveform of the composite signal."""

# Step 2: Time-Domain Plot

plt.figure(figsize=(10, 4))
plt.plot(t, x)
plt.title("Time-Domain Composite Signal")
plt.xlabel("Time [s]")
plt.ylabel("Amplitude")
plt.xlim(0, 0.3)
plt.grid()
plt.show()

"""(c) Compute the Discrete-Time Fourier Transform (DTFT) and plot the continuous frequency spectrum."""

# Step 3: DTFT (Approximated with Zero-Padding)

Nfft = 8192
X_dtft = np.fft.fft(x, Nfft)
freq_dtft = np.fft.fftfreq(Nfft, d=1/fs)

pos_mask = freq_dtft >= 0
plt.figure(figsize=(10, 4))
plt.plot(freq_dtft[pos_mask], np.abs(X_dtft[pos_mask]))
plt.title("DTFT (Approximation) - Magnitude Spectrum")
plt.xlabel("Frequency [Hz]")
plt.ylabel("Magnitude")
plt.grid()
plt.show()

"""(d) Compute the Discrete Fourier Transform (DFT) and plot the discrete frequency spectrum."""

# Step 4: DFT (Normal FFT)

N = len(x)
X_dft = np.fft.fft(x)
freq_dft = np.fft.fftfreq(N, d=1/fs)

plt.figure(figsize=(10, 4))
plt.stem(freq_dft[freq_dft >= 0], np.abs(X_dft[freq_dft >= 0]), basefmt=" ")
plt.title("DFT - Discrete Frequency Spectrum")
plt.xlabel("Frequency [Hz]")
plt.ylabel("Magnitude")
plt.grid()
plt.show()

"""(a) Generate an exponentially decaying signal."""

import numpy as np
import matplotlib.pyplot as plt


# Step 1: Generate Exponentially Decaying Signal

fs = 1000   # Sampling frequency
T = 1       # Duration
t = np.arange(0, T, 1/fs)

A = 1.0
alpha = 5.0   # Decay rate
x = A * np.exp(-alpha * t)

"""(b) Plot the time-domain waveform."""

# Step 2: Time-Domain Plot

plt.figure(figsize=(10, 4))
plt.plot(t, x)
plt.title("Time-Domain Signal: Exponentially Decaying Signal")
plt.xlabel("Time [s]")
plt.ylabel("Amplitude")
plt.grid()
plt.show()

"""(c) Compute the Discrete-Time Fourier Transform (DTFT) and plot the continuous frequency spectrum."""

# Step 3: DTFT (Approximation)

Nfft = 8192
X_dtft = np.fft.fft(x, Nfft)
freq_dtft = np.fft.fftfreq(Nfft, d=1/fs)

pos_mask = freq_dtft >= 0
plt.figure(figsize=(10, 4))
plt.plot(freq_dtft[pos_mask], np.abs(X_dtft[pos_mask]))
plt.title("DTFT (Approximation) - Magnitude Spectrum")
plt.xlabel("Frequency [Hz]")
plt.ylabel("Magnitude")
plt.grid()
plt.show()

"""(d) Compute the Discrete Fourier Transform (DFT) and plot the discrete frequency spectrum."""

# Step 4: DFT (Normal FFT)

N = len(x)
X_dft = np.fft.fft(x)
freq_dft = np.fft.fftfreq(N, d=1/fs)

plt.figure(figsize=(10, 4))
plt.stem(freq_dft[freq_dft >= 0], np.abs(X_dft[freq_dft >= 0]), basefmt=" ")
plt.title("DFT - Discrete Frequency Spectrum")
plt.xlabel("Frequency [Hz]")
plt.ylabel("Magnitude")
plt.grid()
plt.show()

"""(e) Analyze the relationship between the time-domain waveform and the frequency-domain representation is the question"""

import numpy as np
import matplotlib.pyplot as plt

# ---------------------
# Parameters
# ---------------------
fs = 1000   # Sampling frequency
T = 1       # Duration in seconds
t = np.arange(0, T, 1/fs)

# Two decay rates for comparison
alpha_slow = 2.0   # Slow decay
alpha_fast = 10.0  # Fast decay

# Generate signals
x_slow = np.exp(-alpha_slow * t)
x_fast = np.exp(-alpha_fast * t)

# ---------------------
# Plot Time-Domain Signals
# ---------------------
plt.figure(figsize=(10, 4))
plt.plot(t, x_slow, label=r'Slow Decay ($\alpha = 2$)')
plt.plot(t, x_fast, label=r'Fast Decay ($\alpha = 10$)')
plt.title("Time-Domain Comparison: Exponential Decay")
plt.xlabel("Time [s]")
plt.ylabel("Amplitude")
plt.legend()
plt.grid()
plt.show()

# ---------------------
# Compute DTFT (using zero-padded FFT)
# ---------------------
Nfft = 8192
X_dtft_slow = np.fft.fft(x_slow, Nfft)
X_dtft_fast = np.fft.fft(x_fast, Nfft)
freq_dtft = np.fft.fftfreq(Nfft, d=1/fs)
pos_mask = freq_dtft >= 0

# ---------------------
# Plot Frequency-Domain Magnitude Spectra
# ---------------------
plt.figure(figsize=(10, 4))
plt.plot(freq_dtft[pos_mask], np.abs(X_dtft_slow[pos_mask]),
         label=r'Slow Decay ($\alpha = 2$)')
plt.plot(freq_dtft[pos_mask], np.abs(X_dtft_fast[pos_mask]),
         label=r'Fast Decay ($\alpha = 10$)')
plt.title("Frequency-Domain Comparison: Spectrum of Exponential Decay")
plt.xlabel("Frequency [Hz]")
plt.ylabel("Magnitude")
plt.legend()
plt.grid()
plt.show()

"""(a) Generate a rectangular pulse signal of finite duration in the time domain."""

import numpy as np
import matplotlib.pyplot as plt

# Step 1: Generate Rectangular Pulse

fs = 1000   # Sampling frequency
T = 1       # Total signal duration
t = np.arange(0, T, 1/fs)

Tp = 0.1    # Pulse width (seconds)
x = np.where(t < Tp, 1.0, 0.0)  # Rectangular pulse

"""(b) Plot the time-domain waveform."""

# Step 2: Time-Domain Plot

plt.figure(figsize=(10, 4))
plt.plot(t, x)
plt.title("Time-Domain Signal: Rectangular Pulse")
plt.xlabel("Time [s]")
plt.ylabel("Amplitude")
plt.ylim(-0.1, 1.2)
plt.grid()
plt.show()

"""(c) Compute the Discrete-Time Fourier Transform (DTFT) and plot the continuous frequency spectrum."""

# Step 3: DTFT (Approximated with Zero-Padding)

Nfft = 8192
X_dtft = np.fft.fft(x, Nfft)
freq_dtft = np.fft.fftfreq(Nfft, d=1/fs)

pos_mask = freq_dtft >= 0
plt.figure(figsize=(10, 4))
plt.plot(freq_dtft[pos_mask], np.abs(X_dtft[pos_mask]))
plt.title("DTFT (Approximation) - Magnitude Spectrum (Sinc Shape)")
plt.xlabel("Frequency [Hz]")
plt.ylabel("Magnitude")
plt.grid()
plt.show()

"""(d) Compute the Discrete Fourier Transform (DFT) and plot the discrete frequency spectrum."""

# Step 4: DFT (Normal FFT)

N = len(x)
X_dft = np.fft.fft(x)
freq_dft = np.fft.fftfreq(N, d=1/fs)

plt.figure(figsize=(10, 4))
plt.stem(freq_dft[freq_dft >= 0], np.abs(X_dft[freq_dft >= 0]), basefmt=" ")
plt.title("DFT - Discrete Frequency Spectrum")
plt.xlabel("Frequency [Hz]")
plt.ylabel("Magnitude")
plt.grid()
plt.show()

"""(e) Analyze the relationship between the time-domain waveform and the frequency-domain representation."""

import numpy as np
import matplotlib.pyplot as plt

# ---------------------
# Parameters
# ---------------------
fs = 1000     # Sampling frequency
T = 1         # Total duration
t = np.arange(0, T, 1/fs)

Tp = 0.1      # Pulse width
x = np.where(t < Tp, 1.0, 0.0)  # Rectangular pulse

# ---------------------
# Time-Domain Plot
# ---------------------
plt.figure(figsize=(10, 3))
plt.plot(t, x, label="Rectangular Pulse")
plt.title("Time-Domain: Rectangular Pulse")
plt.xlabel("Time [s]")
plt.ylabel("Amplitude")
plt.ylim(-0.2, 1.2)
plt.legend()
plt.grid()
plt.show()

# ---------------------
# DTFT (Zero-Padded FFT for Smooth Spectrum)
# ---------------------
Nfft = 8192
X_dtft = np.fft.fft(x, Nfft)
freq_dtft = np.fft.fftfreq(Nfft, d=1/fs)
pos_mask = freq_dtft >= 0

# ---------------------
# Frequency-Domain Plot with Main Lobe Highlight
# ---------------------
plt.figure(figsize=(10, 4))
plt.plot(freq_dtft[pos_mask], np.abs(X_dtft[pos_mask]), label="Magnitude Spectrum")
plt.axvline(x=1/Tp, color='r', linestyle='--', label="Main Lobe Edge (±1/Tp)")
plt.axvline(x=-1/Tp, color='r', linestyle='--')
plt.title("Frequency-Domain: Sinc-Shaped Spectrum")
plt.xlabel("Frequency [Hz]")
plt.ylabel("Magnitude")
plt.legend()
plt.grid()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Parameters
Fs = 1000  # Sampling frequency (Hz)
T = 1/Fs   # Sampling period
t = np.arange(-0.5, 0.5, T)  # Time vector (1 second window)

# Generate rectangular pulses of different widths
widths = [0.1, 0.2, 0.4]  # pulse widths in seconds
plt.figure(figsize=(12, 6))

for i, w in enumerate(widths):
    # Time-domain rectangular pulse
    rect = np.where(np.abs(t) <= w/2, 1, 0)

    # Compute DFT
    N = len(rect)
    Rect_FFT = np.fft.fftshift(np.fft.fft(rect, N))
    freq = np.fft.fftshift(np.fft.fftfreq(N, T))

    # Normalize magnitude
    Rect_mag = np.abs(Rect_FFT) / np.max(np.abs(Rect_FFT))

    # Plot frequency domain
    plt.subplot(2, len(widths), i+1)
    plt.plot(t, rect)
    plt.title(f"Rectangular Pulse (Width={w}s)")
    plt.xlabel("Time (s)")
    plt.ylabel("Amplitude")
    plt.grid()

    plt.subplot(2, len(widths), i+1+len(widths))
    plt.plot(freq, Rect_mag)
    plt.title(f"Frequency Spectrum (Width={w}s)")
    plt.xlabel("Frequency (Hz)")
    plt.ylabel("Normalized Magnitude")
    plt.grid()

plt.tight_layout()
plt.show()

"""# **Complexity**

"""

import numpy as np
import matplotlib.pyplot as plt

# Parameters
Fs = 1000      # Sampling frequency
N = 256        # Number of samples
t = np.arange(N) / Fs

# Choose a frequency that does NOT complete an integer number of cycles
f_noninteger = 50.5  # Hz (will cause spectral leakage)
signal = np.sin(2 * np.pi * f_noninteger * t)

# Compute FFT without window
X = np.fft.fftshift(np.fft.fft(signal, N))
freq = np.fft.fftshift(np.fft.fftfreq(N, 1/Fs))
X_mag = np.abs(X)

# Apply a window (Hamming window)
window = np.hamming(N)
signal_win = signal * window
X_win = np.fft.fftshift(np.fft.fft(signal_win, N))
X_win_mag = np.abs(X_win)

# Plot results
plt.figure(figsize=(14, 8))

# Time-domain signal
plt.subplot(3, 1, 1)
plt.plot(t, signal, label="Original Signal")
plt.title("Time-Domain Signal (Non-Integer Cycle Frequency)")
plt.xlabel("Time [s]")
plt.ylabel("Amplitude")
plt.grid()

# Spectrum without window
plt.subplot(3, 1, 2)
plt.plot(freq, X_mag, label="Without Window", color='red')
plt.title("Frequency Spectrum (Without Window) - Spectral Leakage Visible")
plt.xlabel("Frequency [Hz]")
plt.ylabel("Magnitude")
plt.xlim(0, 150)
plt.grid()

# Spectrum with Hamming window
plt.subplot(3, 1, 3)
plt.plot(freq, X_win_mag, label="With Hamming Window", color='green')
plt.title("Frequency Spectrum (With Window) - Leakage Reduced")
plt.xlabel("Frequency [Hz]")
plt.ylabel("Magnitude")
plt.xlim(0, 150)
plt.grid()

plt.tight_layout()
plt.show()

import numpy as np

# Parameters
Fs = 1000
N = 512
t = np.arange(N) / Fs

# Generate a composite signal
x = np.sin(2*np.pi*50*t) + 0.5*np.sin(2*np.pi*120*t)

# Compute energy in time domain
E_time = np.sum(np.abs(x)**2)

# Compute energy in frequency domain using DFT
X = np.fft.fft(x, N)
E_freq = np.sum(np.abs(X)**2) / N  # Parseval's relation

print(f"Energy in Time Domain: {E_time:.4f}")
print(f"Energy in Frequency Domain: {E_freq:.4f}")

if np.isclose(E_time, E_freq, rtol=1e-5):
    print("✅ Parseval's theorem verified: Energy is conserved!")
else:
    print("⚠️ Parseval's theorem not matched (check computation)")

import numpy as np
import matplotlib.pyplot as plt

# Parameters
Fs = 1000
N = 512
t = np.arange(N) / Fs

# Create a noisy signal (sinusoid + noise)
x = np.sin(2*np.pi*50*t) + 0.5*np.random.randn(N)

# Compute DFT
X = np.fft.fft(x, N)
freq = np.fft.fftfreq(N, 1/Fs)

# Apply a simple low-pass filter in frequency domain
cutoff = 80  # Hz
X_filtered = X.copy()
X_filtered[np.abs(freq) > cutoff] = 0  # zero-out high frequencies

# Reconstruct time-domain signal using IDFT
x_filtered = np.fft.ifft(X_filtered)

# Plot results
plt.figure(figsize=(14, 6))

plt.subplot(2, 1, 1)
plt.plot(t, x, label='Noisy Signal')
plt.title("Noisy Signal (Time Domain)")
plt.xlabel("Time [s]")
plt.ylabel("Amplitude")
plt.grid()

plt.subplot(2, 1, 2)
plt.plot(t, x_filtered.real, label='Filtered Signal', color='green')
plt.title("Reconstructed Signal after Low-Pass Filtering")
plt.xlabel("Time [s]")
plt.ylabel("Amplitude")
plt.grid()

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# Parameters
N = 128
L_values = [4, 8, 16, 32, 64]
freq = np.linspace(-np.pi, np.pi, N)
spectra = []

# Compute spectra for different L values
for L in L_values:
    x = np.zeros(N)
    x[:L] = 1
    X = np.fft.fftshift(np.fft.fft(x))
    spectra.append(np.abs(X))

spectra = np.array(spectra)

# 3D Plot
fig = plt.figure(figsize=(10,6))
ax = fig.add_subplot(111, projection='3d')

F, L_grid = np.meshgrid(freq, L_values)
ax.plot_surface(F, L_grid, spectra, cmap='viridis')

ax.set_xlabel('Frequency (rad/sample)')
ax.set_ylabel('Pulse Width (L)')
ax.set_zlabel('|X(e^jw)|')
ax.set_title('3D Visualization: Pulse Width vs Spectrum')
plt.show()

import seaborn as sns

# Use the spectra from the 3D example
plt.figure(figsize=(8,6))
sns.heatmap(spectra, cmap='magma', xticklabels=False, yticklabels=L_values)
plt.title("Spectral Energy Heatmap for Different Pulse Widths")
plt.xlabel("Frequency Index")
plt.ylabel("Pulse Width (L)")
plt.show()

# Generate two signals: pulse and moving average filter
x = np.zeros(64)
x[16:32] = 1  # rectangular pulse
h = np.ones(5) / 5  # moving average

# Time-domain convolution
y_time = np.convolve(x, h, mode='same')

# Frequency-domain multiplication
X = np.fft.fft(x, 64)
H = np.fft.fft(h, 64)
Y_freq = X * H
y_freq = np.fft.ifft(Y_freq)

plt.figure(figsize=(10,6))
plt.subplot(3,1,1)
plt.stem(x, basefmt="k"); plt.title("Input Signal x[n]")
plt.subplot(3,1,2)
plt.stem(y_time, basefmt="k"); plt.title("Output via Time-Domain Convolution")
plt.subplot(3,1,3)
plt.stem(np.real(y_freq), basefmt="k"); plt.title("Output via Freq-Domain Multiplication (IDFT)")
plt.tight_layout()
plt.show()